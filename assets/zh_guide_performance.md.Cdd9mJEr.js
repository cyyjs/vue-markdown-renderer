import{_ as o,c as r,o as d,ag as i}from"./chunks/framework.C0wiDQbp.js";const _=JSON.parse('{"title":"性能特性与建议","description":"","frontmatter":{},"headers":[],"relativePath":"zh/guide/performance.md","filePath":"zh/guide/performance.md"}'),c={name:"zh/guide/performance.md"};function t(a,e,l,n,s,p){return d(),r("div",null,[...e[0]||(e[0]=[i('<h1 id="性能特性与建议" tabindex="-1">性能特性与建议 <a class="header-anchor" href="#性能特性与建议" aria-label="Permalink to &quot;性能特性与建议&quot;">​</a></h1><p>本渲染器针对流式与大型文档进行优化。</p><p>关键功能：</p><ul><li>针对代码块的增量解析</li><li>最小化的 DOM 更新与内存优化</li><li>Monaco 的流式更新</li><li>渐进式 Mermaid 渲染</li></ul><p>性能建议：</p><ul><li>将长文档分块流式传输，避免阻塞主线程</li><li>对只读代码块使用 <code>MarkdownCodeBlockNode</code> 或 <code>renderCodeBlocksAsPre</code></li><li>使用 <code>setDefaultMathOptions</code> 在应用启动时设置数学渲染默认项</li><li>对重型节点启用 <code>viewportPriority</code>（默认开启）以延迟离屏工作</li></ul><p>更多详细信息见 <code>/zh/guide/performance</code>。</p><h2 id="让渲染保持稳定的-逐字更新" tabindex="-1">让渲染保持稳定的“逐字更新” <a class="header-anchor" href="#让渲染保持稳定的-逐字更新" aria-label="Permalink to &quot;让渲染保持稳定的“逐字更新”&quot;">​</a></h2><p>有些 LLM 会一次推送大量文本，导致前端表现为“卡顿一会儿再一次性显示”。想让用户始终看到稳定的打字机效果，可以：</p><ul><li><strong>保持 <code>typewriter</code> 为默认开启</strong>，这样非代码节点都会通过进入动画逐字呈现。</li><li><strong>调整批次渲染参数</strong>：调低 <code>initialRenderBatchSize</code> / <code>renderBatchSize</code>（如 <code>12</code> / <code>24</code>），并设置一个 20–30 ms 的 <code>renderBatchDelay</code>，让每次渲染只插入很小的一段文本。</li><li><strong>在上游做节流或拆包</strong>：把后端一次性推送的大段文本按段落拆分，或用 50–100 ms 的防抖再更新 <code>content</code>，减少一次性 diff。</li><li><strong>保留延迟可见渲染</strong>：继续启用 <code>deferNodesUntilVisible</code> / <code>viewportPriority</code>，避免 Mermaid、Monaco 这类重型节点阻塞文字流。</li><li><strong>必要时降级代码块</strong>：在突发大块传输时暂时关闭 <code>codeBlockStream</code> 或启用 <code>renderCodeBlocksAsPre</code>，避免语法高亮抢占时间片。</li></ul><p>这些组合可以把 DOM 工作量稳定在可控范围，哪怕服务端一次发送很多文本，用户也会感知为持续、丝滑的逐字输出。</p>',11)])])}const h=o(c,[["render",t]]);export{_ as __pageData,h as default};
